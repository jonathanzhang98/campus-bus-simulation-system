/**
 * @file mainpage.h
 *
 * @copyright 2020 Zixuan Zhang, All rights reserved.
 */
#ifndef SRC_MAINPAGE_H_
#define SRC_MAINPAGE_H_

/*! \mainpage Bus Simulator
 *
 * \section A Getting started with the Bus Simulator
 * 1. Obtaining the code
 *
 *    All the code that's relavent to the bus simulator is in the project folder.
 *
 *      The src directory contains the source code of all the real-world objects in the simulation.
 *
 *      The web_code directory contains the source code of the server.
 *
 *      The web_graphics directory contains the source code of the client.
 *
 *      The tests directory contains the automated unit testing.
 *
 *      The build directory contains all the target files (.o, exe) generated by the compiler.
 *
 *      The docs directory contains all the documentation files for the simulator.
 *
 * 2. Configuration
 *
 *    In the config directory of the project folder, there's a config.txt file while contains all the information concerning the routes in this simulation.
 *    By modifying the config.txt file, you can add, delete, or modify routes and the stops of these routes.
 *
 * 3. Compilation
 *
 *    Step 1: navigate to the src directory in the project folder in your terminal
 *
 *    Step 2: type the "make" command
 * 
 * 4. Executaion
 *
 *    Step 1: After you successfully compiledd the simulation, you can navigate back to your project directy and run the following command:
 *          ./build/bin/vis_sim <port_number> 
 *          Note: the port_number must be larger than 8000, and the last 3 digits can be chosen randomly
 *      
 *    Step 2: After this, your terminal should be showing the message: "starting server..."
 *
 *    Step 3: Now, you can open your brower can go to the following URL:
 *          http://127.0.0.1:<port_number>/web_graphics/project.html
 *          Note: <port_number> is just the port number you typed in step 1
 *
 *    Step 4: You can then start the simulation by clicking the start button, and while the simulation is running, you can click the pause/resume button to pause or resume the simulation.
 *
 *
 * \section B The Design of Bus Factory
 * The bus factory can be implemented as both a concrete factory or an abstract factory.
 * 
 * A concrete bus factory uses a static function to create and return a bus object, while an abstract factory create an interface for specific concrete factories that will inherite from it.
 * 
 * When comparing to an abstract factory, a concrete bus factory is easier to implements since there is only one class to create in a concrete bus factory. In an abstract factory instead, there are at least 4 classes needed to be created which add some complexities.
 * However, a concrete bus factory cannot provides only one layer of abstraction. It only classify our concrete bus objects in terms of one attribute.
 * 
 * An abstract factory, on the other hand, can classify buses using two different attributes, such as capacity and which campus the bus is in. For example, using an abstract factory, we can differentiate small buses in the Twin Cities campus from small buses in the Duluth campus.
 * Nevertheless, this extra layer of an abstract factory adds much more complexity to the implementation process of it. Typically an abstract factory requires more classes to be implemented to achieve the same functionality of an concrete factory. 
 * 
 * In the context of this simulation, there's no need to an extra layer of complexity since we only need to classify our buses in terms of their capacity. In this case, a concrete bus factory will be much easier to implement and reduces the complexity of our simulation.
 *
 *
 
 \section C Designing and Implementing the Observer Pattern
 * To implement the observer pattern for observing information about a bus as it proceeds along a route, we must first idenify what is the observer and what is the subject.
 * In our case, the bus class is our subject since it contains the information we want and this information changes over time. And our frontend UI interface is the observer
 * which shows the information when being notified.
 *
 * Therefore, I added two classes that's key to the observer pattern: IObserver and IObservable.
 *
 * IObserver defines an observer interface. And since an observer need to update itself when information is passed along to it, IObserver has a method called 'UpdateObserver'. I defined it to be a pure virtual function since it cannot be implemented without further information.
 * 
 * IObservable defines a subject interface. It has a private member field called observer_ to store all the observers it needs to notify. It also supports several operations which are: 
 * 1. RegisterObserver: this function add an observer to the subject's observer list.
 * 2. ClearObserver: this function clears out all observers of this subject.
 * 3. NotifyObserver: this function notifies all observers with updated information.
 * Unlike IObserver, IObservable can implement all three of these functions.
 * 
 * After creating the interfaces of the observer pattern.
 * I modified bus.h file and let Bus class inherit from IObservable class to change Bus to a subject in the observer pattern. Then, I added a line of code in the update method to call the NotifyObserver function because bus_data_ is changed by update method.
 * 
 * For me, the most difficult part of designing and implementing this pattern is to understand how all the classes and methods fit together and why we should use observer pattern. I would suggest first understand what are the downsides of the brute force solution before diving into the observer pattern.
 * 
 * Resources that helped me understand the observer pattern:
 * 1. https://sourcemaking.com/design_patterns/strategy/cpp/1 
 * 2. Head First Design Patterns
 * 3. https://www.geeksforgeeks.org/observer-pattern-set-1-introduction/

 \section D Designing and Implementing the Decorator Pattern
 * Our rationale for using the decorator pattern is that we want to dynamically add behaviors to our base objects without the need to modifting exsiting code. At first, we came up with the idea of changing the color of buses based on the route they are on.
 * Then, we came up with the idea of changing the intensity of buses based on the number of passengers on the buses. Therefore, it won't be a suprise if we want to add some other functionality to the bus class in the future.
 * 
 * Generally, we have two approaches for adding these functionalty. We can either directly modify the bus class to support these functionality or we can use decorator pattern to decorate bus objects so we don't need to modify the bus class again and again
 * the next time we want to add some new functionality, which inevitably introduces new bugs and break things.
 * 
 * The classes and methods I added:
 *
 *
 * 1. IBus as a general interface, it has all the methods that the bus class needs and all these methods are pure virtual.
 * 2. BusDecorator class inherites from IBus interface and also has a constructor.
 * 3. BusColorDecorator class inherites from BusDecorator and overrides the GetBusData() method to add the functionality of changing bus color based on the route the bus is on.
 * 4. BusIntensityDecorator class inherites from BusDecorator and overrides the GetBusData() method to add the functionality of changing bus color intensity based on number of passengers on the bus.
 * 
 * The decorator pattern design I implemented is the standard one which involves a common component interface (both concrete components and decorator interface inherites from) and a decorator interface which concrete decorators inherites from.
 * I chose this design because it adheres to the SOLID principles.
 * 1. It adhere to the single responsibility principle because every class in this design has only one single responsibility, the bus class is not doing the job of decorator classes.
 * 2. It adhere to the open/closed principle because we can add on behaviors to the bus class just by creating new decorator classes without modifying any existing code.
 * 3. It adhere to the Liskov's substitution principle because subclasses in this design can substitude superclasses. Decorater classes can do all the job IBus interface can do.
 * 4. It adhere to the interface segregation principle because no subclasses are enforced to inherite behaviors that they do not want.
 * 5. It adhere to the dependency inversion principle because code that uses IBus do not know about any changes happend inside of the it.
 *
 * Another design for fullfiling this requirement is to have a class inheriting from Bus class and adds additional function of changing color based on routes by overriding some super class methods.
 * This design is bad because it breaks some SOLID principles and causes some problems.
 * 1. It breaks the single responsibility principle because the subclass is trying to do both the job of the bus class and the job of decorator class.
 * 2. It breaks the dependency inversion principle because code that uses the subclasses of the Bus class needs to know which subclass to instantiate based on the requirements and the 'new' statement needs to change.
 * 3. It is not dry because there can be two subclasses using the same behavior can code is duplicated between these two classes.
 * 4. This design will lead to class explosion as wanted behaviors grow and the combination of wanted behaviors grow. If we have 10 wanted behavioors, we may need to have 2 ^ 10 = 1024 subclasses.
 *
 * The most difficult part of the design and implementation of the decorator pattern is to understand the inheritance hierarchy and figure out what methods should be pure virtual, what methods belong to the base class, and what methods belong to decorators
 * (i.e. figure out the responsibilities of all the classes involved in the decorator pattern) 
 * 
 * Tips on how to understand and implement the decorator pattern:
 * 1. Both decorators and concrete components inherite from components so both of them can be treated as component interface.
 * 2. Decorators need to have a base class which they can decorate on.
 * 3. Decorator pattern favors composition over inheritance.
 * 4. Understand the responsibility of base class and decorators.
 * 4. Draw the control flow from outside to the inside and back to the outside, and understand the relationships between decorators and base classes.
 * 5. https://www.tutorialspoint.com/design_pattern/decorator_pattern.htm
 * 6. https://refactoring.guru/design-patterns/decorator
 * 7. https://www.geeksforgeeks.org/the-decorator-pattern-set-2-introduction-and-design/
 */

#endif  // SRC_MAINPAGE_H_
